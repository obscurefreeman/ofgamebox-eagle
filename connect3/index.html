<!DOCTYPE html>
<html>
  <head>
    <title>Connect 3</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link href="https://fonts.googleapis.com/css?family=Roboto:300" rel="stylesheet">
    <style>
	html, body {
  height: 100%;
  width: 100%;
}
body {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 0;
  font-size: 0;
  background-color: #303030;
  color: white;
  font-family: 'Roboto', sans-serif;
}
.grid {
  background-color: #424242;
  padding: 20px;
  box-shadow: 0 6px 24px rgba(0,0,0,0.3);
  border-radius: 2px;
  width: 355px;
  height: 355px;
  position: relative;
}
.grid::after {
  content: attr(data-score);
  font-size: 72px;
  text-align: center;
  display: block;
  width: 100%;
  position: absolute;
  bottom: 100%;
  left: 0;
}
.grid > span {
  position: absolute;
  padding: 20px;
  border-radius: 2px;
  background-position: center;
  background-repeat: no-repeat;
  background-size: 20px;
  box-shadow: 0 0.5px 3px rgba(0,0,0,0.3);
  transition: left .2s, top .2s;
}
.grid > span.square {
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 10' stroke-linejoin='round' fill='none' stroke='rgba(0,0,0,0.3)' stroke-width='1'%3E%3Cpath d='M1 1H9V9H1z'/%3E%3C/svg%3E")
}
.grid > span.circle {
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 10' fill='none' stroke='rgba(0,0,0,0.3)' stroke-width='1'%3E%3Ccircle cx='5' cy='5' r='4'/%3E%3C/svg%3E")
}
.grid > span.triangle {
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 10' stroke-linejoin='round' fill='none' stroke='rgba(0,0,0,0.3)' stroke-width='1'%3E%3Cpath d='M5 1.5L9 8.5H1z'/%3E%3C/svg%3E")
}
.grid > span.plus {
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 10' stroke-linecap='round' fill='none' stroke='rgba(0,0,0,0.3)' stroke-width='1'%3E%3Cpath d='M5 1V9M1 5H9'/%3E%3C/svg%3E")
}
.grid > span.minus {
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 10' stroke-linecap='round' fill='none' stroke='rgba(0,0,0,0.3)' stroke-width='1'%3E%3Cpath d='M2 5H8'/%3E%3C/svg%3E")
}
.grid > span.hexagon {
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 10' stroke-linejoin='round' fill='none' stroke='rgba(0,0,0,0.3)' stroke-width='1'%3E%3Cpath d='M4 1H8L10.6 5L8 9H4L1.4 5z'/%3E%3C/svg%3E");
  background-size: 24px 20px;
}
.grid > span.dot {
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 10' fill='rgba(0,0,0,0.3)'%3E%3Ccircle cx='5' cy='5' r='1'/%3E%3C/svg%3E");
}
.grid > span::after {
  content: '';
  pointer-events: none;
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  background-size: 100%;
  background-position: center;
  background-repeat: no-repeat;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 10' stroke-linejoin='round' stroke-linecap='round' fill='none' stroke='white' stroke-width='1'%3E%3Cpath d='M1 2V1H2M9 8V9H8 M9 2V1H8M2 9H1V8'/%3E%3C/svg%3E");
  transform: scale(1.2);
  opacity: 0;
  transition: all .2s;
}
.grid > span.active::after {
  transform: scale(1);
  opacity: 1;
}
.grid > span.entering {
  padding: 0 20px;
  animation: entering .2s .2s forwards;
}
@keyframes entering {
  from {padding: 0 20px;}
  to {padding: 20px;}
}
.grid > span.exiting {
  pointer-events: none;
  animation: exiting .2s forwards;
}
@keyframes exiting {
  from {padding: 20px; margin-top: 0;}
  to {padding: 0 20px; margin-top: 40px;}
}
	</style>
  </head>
  <body>
    <script>
      const colours = ["red", "orange", "yellow", "dodgerblue", "limegreen", "darkorchid", "hotpink"],
      shapes = ["minus", "circle", "triangle", "plus", "square", "hexagon", "dot"],
      BOARD_SIZE = 8,
      score = {
        set(n) {
          score.number = n;
          squareElem.dataset.score = n;
        },
        add(n) {
          this.set(n + this.number);
        }
      };
      class Tile {
        constructor(x, y, colour, entering = false) {
          this.colour = -1;

          this.element = document.createElement("span");
          this.element.addEventListener("click", e => {
            if (selectedTile === 'DONTSELECT');
            else if (selectedTile) {
              if (selectedTile.x === this.x && Math.abs(selectedTile.y - this.y) === 1
                  || selectedTile.y === this.y && Math.abs(selectedTile.x - this.x) === 1) {
                let lastPositions = {
                  me: [this.x, this.y],
                  selectedTile: [selectedTile.x, selectedTile.y, selectedTile.elem]
                };
                selectedTile.moveTileTo(this.x, this.y);
                this.moveTo(selectedTile.x, selectedTile.y);
                selectedTile = null;

                if (!startMurderSpree(200)) {
                  selectedTile = 'DONTSELECT';
                  setTimeout(() => {
                    lastPositions.selectedTile[2].moveTo(lastPositions.selectedTile[0], lastPositions.selectedTile[1]);
                    this.moveTo(lastPositions.me[0], lastPositions.me[1]);
                    selectedTile = null;
                  }, 200);
                }
                return;
              } else {
                if (selectedTile.cancel() === this) return;
              }
            }
            if (!selectedTile) {
              this.element.classList.add("active");
              selectedTile = {
                x: this.x,
                y: this.y,
                moveTileTo: (x, y) => {
                  this.moveTo(x, y);
                  this.element.classList.remove("active");
                },
                cancel: () => {
                  this.element.classList.remove("active");
                  selectedTile = null;
                  return this;
                },
                elem: this
              };
            }
          }, false);

          switch (colour) {
            case "bomb":
              this.element.classList.add("bomb");
            default:
              this.element.classList.add(shapes[colour]);
              this.element.style.backgroundColor = colours[colour];
              this.colour = colour;
          }

          if (entering) this.element.classList.add("entering");
          squareElem.appendChild(this.element);

          this.x = x;
          this.y = y;
          this.moveTo(x, y);
        }
        remove(animate = true, addNewItem = true) {
          if (animate) {
            this.element.classList.add("exiting");
            this.element.addEventListener("animationend", e => {
              squareElem.removeChild(this.element);
            }, false);
          }
          else squareElem.removeChild(this.element);
          tileElems[this.y][this.x] = null, tiles[this.y][this.x] = null;
          for (let tempY = this.y; tempY--;) tileElems[tempY][this.x].moveTo(this.x, tempY + 1);
          if (addNewItem) {
            new Tile(this.x, 0, Math.floor(Math.random() * colours.length), true);
          }
          if (selectedTile && selectedTile.elem === this) selectedTile = null;
        }
        moveTo(x, y) {
          if (tileElems[this.y][this.x] === this) tileElems[this.y][this.x] = null, tiles[this.y][this.x] = null;
          this.element.style.left = ((this.x = x) * 45 + 20) + "px";
          this.element.style.top = ((this.y = y) * 45 + 20) + "px";
          tileElems[y][x] = this, tiles[y][x] = this.colour;
        }
      }
      function startMurderSpree(wasRightAfterTransition = false) {
        let foundMatches,
        combo = 0,
        toRemove = [];
        while ((foundMatches = checkForMatches(tiles)).length) {
          for (let i = foundMatches.length; i--;) for (let j = foundMatches[i].length; j--;) {
            let tile = tileElems[foundMatches[i][j][1]][foundMatches[i][j][0]];
            if (!toRemove.includes(tile)) {
              toRemove.push(tile);
              tiles[foundMatches[i][j][1]][foundMatches[i][j][0]] = NaN;
            }
          }
          combo++;
        }
        let killing = () => {
          for (let i = toRemove.length; i--;) toRemove[i].remove();
          score.add(toRemove.length * 100);
          startMurderSpree(400);
        };
        if (combo !== 0) {
          if (wasRightAfterTransition) setTimeout(killing, wasRightAfterTransition);
          else killing();
        }
        return combo !== 0;
      }
      function checkForMatches(tiles) {
        function getCoords(x, y, ywise = true, frontOffset = 0, sideOffset = 0) {
          return [x + (ywise ? sideOffset : frontOffset), y + (ywise ? frontOffset : sideOffset)];
        }
        function getTile(coords) {
          return tiles[coords[1]][coords[0]];
        }
        function areSameColour(tile1, tile2) { // -1 is wildcard; NaN is a unique tile
          return tile1 === -1 || tile2 === -1 || tile1 === tile2;
        }
        function actuallyCheckForMatches(x, y, ywise) {
          let coords = getCoords(x, y),
          colour = getTile(coords),
          matches = [coords],
          frontCoord = ywise ? y : x,
          sideCoord = ywise ? x : y;
          for (let i = 1; i < 6 && frontCoord - i >= 0; i++) {
            let coords = getCoords(x, y, ywise, -i);
            if (areSameColour(colour, getTile(coords))) matches.push(coords);
            else break;
          }
          if (matches.length >= 3) {
            let actualMatches = [matches];
            for (let i = matches.length; i--;) {
              let sideMatches = [getCoords(x, y, ywise, -i)],
              leftIsDone = false,
              rightIsDone = false;
              for (let j = 1; j < 6; j++) {
                let leftCoords = getCoords(x, y, ywise, -i, -j),
                rightCoords = getCoords(x, y, ywise, -i, j);
                if (!leftIsDone && sideCoord - j >= 0 && areSameColour(colour, getTile(leftCoords))) sideMatches.push(leftCoords);
                else leftIsDone = true;
                if (!rightIsDone && sideCoord + j < 8 && areSameColour(colour, getTile(rightCoords))) sideMatches.push(rightCoords);
                else rightIsDone = true;
                if (leftIsDone && rightIsDone) break;
              }
              if (sideMatches.length >= 3) actualMatches.push(sideMatches);
            }
            return actualMatches;
          }
          return false;
        }
        for (let y = BOARD_SIZE; y--;) for (let x = BOARD_SIZE; x--;) {
          if (y > 1) {
            let matches = actuallyCheckForMatches(x, y, true);
            if (matches) return matches;
          }
          if (x > 1) {
            let matches = actuallyCheckForMatches(x, y, false);
            if (matches) return matches;
          }
        }
        return [];
      }
      let squareElem = document.createElement("div"),
      tiles = [],
      tileElems = [];
      squareElem.classList.add("grid");
      for (let y = 8; y--;) {
        let row = [];
        for (let x = 8; x--;) row.push(Math.floor(Math.random() * colours.length));
        tiles.push(row);
      }
      let foundMatches;
      while ((foundMatches = checkForMatches(tiles)).length) {
        for (let i = 3; i--;) tiles[foundMatches[0][i][1]][foundMatches[0][i][0]] = Math.floor(Math.random() * colours.length);
      }
      let selectedTile = null;
      for (let y = 8; y--;) {
        let elemRow = [];
        tileElems[y] = elemRow;
        for (let x = 8; x--;) new Tile(x, y, tiles[y][x]);
      }
      document.body.appendChild(squareElem);
      score.set(0);
    </script>
  </body>
</html>